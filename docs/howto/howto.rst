.. _howto:

#############
How-to guides
#############


.. note::

   The guides are given for python use. The same can be done from C/Fortran by calls to
   appropriate routines, which generally correspond in the name to the ones from python.
   For more info refer to :ref:`ref_api` and :ref:`src_refs`.




.. contents:: Contents
   :local:
   :depth: 2


Importing the ira module
========================

The IRA library is imported into python by:

>>> import ira_mod

The corresponding algorithm class (IRA or SOFI) has to be initialised by:

>>> ira = ira_mod.IRA()

or

>>> sofi = ira_mod.SOFI()

now, the functions in either class are availably by typing ``ira.<funtion_name>`` or ``sofi.<function_name>``.
Quick help can be accessed by ``help( ira )``, ``help( ira.<function_name> )`` or the same for ``sofi``.


.. warning::
   If the ``ira_mod`` module cannot be found at ``import``, then make sure there is a path to ``/IRA_library/interface``
   in the environment variable ``PYTHONPATH``.
   
   .. code-block:: bash
   
      echo $PYTHONPATH
   
   If not, add it by:
   
   .. code-block:: bash
   
      export PYTHONPATH=/your/path/to/IRA_library/interface:$PYTHONPATH


Construct matrices from axis-angle representation
=================================================

Given an operation in the Schoenflies notation, e.g. S 12^5, the corresponding 3x3 matrix
can be generated by using the ``construct_operation()`` function, given the axis ``ax`` by:

   >>> ## define the axis
   >>> ax = np.array([ 0., 0., 1.] )
   >>> ##
   >>> ## construct operation S 12^5 along the axis
   >>> matrix = sofi.construct_operation( "S", ax, 5/12 )
   >>> matrix
   array([[-0.8660254, -0.5      ,  0.       ],
          [ 0.5      , -0.8660254,  0.       ],
          [ 0.       ,  0.       , -1.       ]])
   >>> ##
   >>> ## giving negative angle should return the transposed matrix
   >>> sofi.construct_operation( "S", ax, -5/12 )
   array([[-0.8660254,  0.5      ,  0.       ],
          [-0.5      , -0.8660254,  0.       ],
          [ 0.       ,  0.       , -1.       ]])
   >>> ##
   >>> ## giving negative axis should return the transpose also
   >>> sofi.construct_operation( "S", -ax, 5/12 )
   array([[-0.8660254,  0.5      ,  0.       ],
          [-0.5      , -0.8660254,  0.       ],
          [ 0.       ,  0.       , -1.       ]])


.. note::
   The axis ``ax`` on input does not need to be normalised.


Obtain axis-angle and Schoenflies fom matrix
============================================

A given orthonormal 3x3 matrix can be analysed to obtain its Schoeflies representation of the format ``Op n^p``,
and the axis-angle representation by calling the ``analmat()`` function:

   >>> ## create a matrix for C 5^2 along axis (1., -1., 1.)
   >>> matrix = sofi.construct_operation( "C", np.array([1., -1., 1.]), 2/5 )
   >>> ##
   >>> ## analyse it
   >>> sofi.analmat( matrix )
   ('C', 5, 2, array([ 0.57735027, -0.57735027,  0.57735027]), 0.4)
   >>> ## save the output
   >>> op, n, p, ax, angle = sofi.analmat( matrix )

The Schoeflies symbol is then ``Op n^p``. The ``angle`` is in units :math:`1/2\pi`, i.e. ``angle=0.5`` is half
the full circle.

NOTE the axis ``ax`` comes from a diagonalisation procedure, therefore any :math:`\pm` direction is a
valid solution. To remove this ambiguity, the convention is that the axis is flipped such that its component are
:math:`z>0`, if :math:`z=0` then :math:`x>0`, and if :math:`x=0` then :math:`y>0` (all within
threshold of numerical precision, which is ``epsilon=1e-6`` by default). The orientation of the angle is then decided based on this axis convention.
Therefore it can happen that analysis of a matrix constructed as:

   >>> matrix = sofi.construct_operation( "C", np.array([-0.3, 1., 0.]), 3/8 )

will flip its axis and angle :

   >>> sofi.analmat( matrix )
   ('C', 8, 3, array([ 2.87347886e-01, -9.57826285e-01, -1.60749682e-16]), -0.375 )


Generate a cyclic group from combinations of matrices
=====================================================

Two or more matrices can be used to create a cyclic group. A cyclic group means any combination of the
elements always generates an element that is inside the group. This can be done by calling the ``mat_combos()``
function:

   >>> ## create an empty list of two 3x3 matrices
   >>> mat_list = np.zeros( [2, 3, 3], dtype=float)
   >>> ##
   >>> ## the first matrix flips over x, and the second over z
   >>> mat_list = np.array([[[-1.,  0.,  0.],
   ...                       [ 0.,  1.,  0.],
   ...                       [ 0.,  0.,  1.]],
   ...
   ...                       [[ 1.,  0.,  0.],
   ...                        [ 0.,  1.,  0.],
   ...                        [ 0.,  0., -1.]]])
   >>> ##
   >>> ## create combinations until group completeness
   >>> n_combo, combo_list = sofi.mat_combos( 2, mat_list )
   >>> n_combo
   4
   >>> combo_list
   array([[[-1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0.,  1.]],
          [[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0., -1.]],
          [[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0.,  1.]],
          [[-1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0., -1.]]])


Determine point group from a list of matrices
=============================================

A point group can be deduced from list of 3x3 orthonormal matrices, using the ``get_pg()`` function.
The determination follows the standard flowchart, i.e. https://symotter.org/assets/flowchart.pdf

   >>> ## create an empty list of four 3x3 matrices
   >>> mat_list = np.zeros( [4, 3, 3], dtype=float)
   >>> ##
   >>> ## add some operations:
   >>> ## identity
   >>> mat_list[0] = sofi.construct_operation("E", np.array([1., 0., 0.]), 0)
   >>> ## mirror over x
   >>> mat_list[1] = sofi.construct_operation("S", np.array([1., 0., 0.]), 0)
   >>> ## mirror over y
   >>> mat_list[2] = sofi.construct_operation("S", np.array([0., 1., 0.]), 0)
   >>> ## mirror over z
   >>> mat_list[3] = sofi.construct_operation("S", np.array([0., 0., 1.]), 0)
   >>> ##
   >>> ## create complete cyclic group by combinations
   >>> n_combo, combo_list = sofi.mat_combos( 4, mat_list )
   >>> ##
   >>> ## what operations does the new list contain?
   >>> for mat in combo_list:
   ...    sofi.analmat( mat )
   ... 
   ('E', 0, 1, array([1., 0., 0.]), 0.0)
   ('S', 0, 1, array([1., 0., 0.]), 0.0)
   ('S', 0, 1, array([0., 1., 0.]), 0.0)
   ('S', 0, 1, array([0., 0., 1.]), 0.0)
   ('C', 2, 1, array([0., 0., 1.]), 0.5)
   ('C', 2, 1, array([0., 1., 0.]), 0.5)
   ('C', 2, 1, array([1., 0., 0.]), 0.5)
   ('I', 2, 1, array([1., 0., 0.]), 0.5)
   >>> ##
   >>> ## get point group and principal axis of the new list
   >>> pg, prin_ax = sofi.get_pg( n_combo, combo_list )
   >>> pg
   'D2h'
   >>> prin_ax
   array([0., 0., 1.])
   >>> ##
   >>> ## a more verbose output can be obtained by setting `verb=True`:
   >>> sofi.get_pg( n_combo, combo_list, verb = True )


Test generator elements
=======================

Now we can test by trial-and-error if certain symmetry elements are generator elements of a group.
For example, the Td point group should be possible to generate from two S4 operations on perpendicular axes.

   >>> ## create empty list of two 3x3 matrices
   >>> mat_list = np.zeros( [2, 3, 3] )
   >>> ##
   >>> ## create two S4 operations, on perpendicular axes
   >>> mat_list[0] = sofi.construct_operation("S", np.array([1., 0., 0.]), 1/4)
   >>> mat_list[1] = sofi.construct_operation("S", np.array([0., 1., 0.]), 1/4)
   >>> ##
   >>> ## generate all combinations
   >>> nc, mc = sofi.mat_combos(2, mat_list)
   >>> ##
   >>> ## determine point group
   >>> sofi.get_pg( nc, mc )
   ('Td', array([-0.57735027, -0.57735027,  0.57735027]))





wishlist
--------

Ideas for how-to/examples:

   - test if particular matrix is a symmetry operation of a structure
   - find symmOps of atomic structure, geo center or specific atom as origin
   - disordered structure, non-complete group, find missing elements
