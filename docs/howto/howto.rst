.. _sofi_howto:

#############################
SOFI tutorial & How-to guides
#############################


.. note::

   The guides are given for python use. The same can be done from C/Fortran by calls to
   appropriate routines, which generally correspond in the name to the ones from python.
   For more info refer to :ref:`ref_api` and :ref:`src_refs`.




.. contents:: Contents
   :local:
   :depth: 2


Importing the ira module
========================

The IRA library is imported into python by:

>>> import ira_mod

The corresponding algorithm class (IRA or SOFI) has to be initialised by:

>>> ira = ira_mod.IRA()

or

>>> sofi = ira_mod.SOFI()

now, the functions in either class are availably by typing ``ira.<funtion_name>`` or ``sofi.<function_name>``.
Quick help can be accessed by ``help( ira )``, ``help( ira.<function_name> )`` or the same for ``sofi``.


.. warning::
   If the ``ira_mod`` module cannot be found at ``import``, then make sure there is a path to ``/IRA_library/interface``
   in the environment variable ``PYTHONPATH``.
   
   .. code-block:: bash
   
      echo $PYTHONPATH
   
   If not, add it by:
   
   .. code-block:: bash
   
      export PYTHONPATH=/your/path/to/IRA_library/interface:$PYTHONPATH


Construct matrices from axis-angle representation
=================================================

Given an operation in the Schoenflies notation, e.g. S 12^5, the corresponding 3x3 matrix
can be generated by using the ``construct_operation()`` function, given the axis ``ax`` by:

   >>> ## define the axis
   >>> ax = np.array([ 0., 0., 1.] )
   >>> ##
   >>> ## construct operation S 12^5 along the axis
   >>> matrix = sofi.construct_operation( "S", ax, 5/12 )
   >>> matrix
   array([[-0.8660254, -0.5      ,  0.       ],
          [ 0.5      , -0.8660254,  0.       ],
          [ 0.       ,  0.       , -1.       ]])
   >>> ##
   >>> ## giving negative angle should return the transposed matrix
   >>> sofi.construct_operation( "S", ax, -5/12 )
   array([[-0.8660254,  0.5      ,  0.       ],
          [-0.5      , -0.8660254,  0.       ],
          [ 0.       ,  0.       , -1.       ]])
   >>> ##
   >>> ## giving negative axis should return the transpose also
   >>> sofi.construct_operation( "S", -ax, 5/12 )
   array([[-0.8660254,  0.5      ,  0.       ],
          [-0.5      , -0.8660254,  0.       ],
          [ 0.       ,  0.       , -1.       ]])


.. note::
   The axis ``ax`` on input does not need to be normalised.


Obtain axis-angle and Schoenflies fom matrix
============================================

A given orthonormal 3x3 matrix can be analysed to obtain its Schoeflies representation of the format ``Op n^p``,
and the axis-angle representation by calling the ``analmat()`` function:

   >>> ## create a matrix for C 5^2 along axis (1., -1., 1.)
   >>> matrix = sofi.construct_operation( "C", np.array([1., -1., 1.]), 2/5 )
   >>> ##
   >>> ## analyse it
   >>> sofi.analmat( matrix )
   ('C', 5, 2, array([ 0.57735027, -0.57735027,  0.57735027]), 0.4)
   >>> ## save the output
   >>> op, n, p, ax, angle = sofi.analmat( matrix )

The Schoeflies symbol is then ``Op n^p``. The ``angle`` is in units :math:`1/2\pi`, i.e. ``angle=0.5`` is half
the full circle.

NOTE the axis ``ax`` comes from a diagonalisation procedure, therefore any :math:`\pm` direction is a
valid solution. To remove this ambiguity, the convention is that the axis is flipped such that its component are
:math:`z>0`, if :math:`z=0` then :math:`x>0`, and if :math:`x=0` then :math:`y>0` (all within
threshold of numerical precision, which is ``epsilon=1e-6`` by default). The orientation of the angle is then decided based on this axis convention.
Therefore it can happen that analysis of a matrix constructed as:

   >>> matrix = sofi.construct_operation( "C", np.array([-0.3, 1., 0.]), 3/8 )

will flip its axis and angle :

   >>> sofi.analmat( matrix )
   ('C', 8, 3, array([ 2.87347886e-01, -9.57826285e-01, -1.60749682e-16]), -0.375 )

.. warning::
   The computation of ``n`` and ``p`` is limited to a certain order, which is by default 24 at maximum.
   If the order of a matrix is larger than that, ``analmat`` will return ``n`` and ``p`` which are wrong, but
   as close as possible to truth, within the `resolution` of 1/24. The ``angle`` will have
   the correct value in any case. Example:

      >>> ## generate a high-order (small angle) rotation C39^2
      >>> matrix = sofi.construct_operation( "C", np.array([ 1., 0., 0.] ), 2/39 )
      >>> ##
      >>> ## attempt to analyse it: n and p are wrong, angle is correct
      >>> sofi.analmat( matrix )
      ('C', 19, 1, array([1., 0., 0.]), 0.051282052)
      >>> ## notice that C39^2 is between C38^2=C19^1 and C40^2=C20^1


Generate a cyclic group from combinations of matrices
=====================================================

Two or more matrices can be used to create a cyclic group. A cyclic group means any combination of the
elements always generates an element that is inside the group. This can be done by calling the ``mat_combos()``
function:

   >>> ## create an empty list of two 3x3 matrices
   >>> mat_list = np.zeros( [2, 3, 3], dtype=float)
   >>> ##
   >>> ## the first matrix flips over x, and the second over z
   >>> mat_list = np.array([[[-1.,  0.,  0.],
   ...                       [ 0.,  1.,  0.],
   ...                       [ 0.,  0.,  1.]],
   ...
   ...                       [[ 1.,  0.,  0.],
   ...                        [ 0.,  1.,  0.],
   ...                        [ 0.,  0., -1.]]])
   >>> ##
   >>> ## create combinations until group completeness
   >>> n_combo, combo_list = sofi.mat_combos( 2, mat_list )
   >>> n_combo
   4
   >>> combo_list
   array([[[-1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0.,  1.]],
          [[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0., -1.]],
          [[ 1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0.,  1.]],
          [[-1.,  0.,  0.],
           [ 0.,  1.,  0.],
           [ 0.,  0., -1.]]])



Determine point group from a list of matrices
=============================================

A point group can be deduced from list of 3x3 orthonormal matrices, using the ``get_pg()`` function.
The determination follows the standard flowchart, i.e. https://symotter.org/assets/flowchart.pdf

   >>> ## create an empty list of four 3x3 matrices
   >>> mat_list = np.zeros( [4, 3, 3], dtype=float)
   >>> ##
   >>> ## add some operations:
   >>> ## identity
   >>> mat_list[0] = sofi.construct_operation("E", np.array([1., 0., 0.]), 0)
   >>> ## mirror over x
   >>> mat_list[1] = sofi.construct_operation("S", np.array([1., 0., 0.]), 0)
   >>> ## mirror over y
   >>> mat_list[2] = sofi.construct_operation("S", np.array([0., 1., 0.]), 0)
   >>> ## mirror over z
   >>> mat_list[3] = sofi.construct_operation("S", np.array([0., 0., 1.]), 0)
   >>> ##
   >>> ## create complete cyclic group by combinations
   >>> n_combo, combo_list = sofi.mat_combos( 4, mat_list )
   >>> ##
   >>> ## what operations does the new list contain?
   >>> for mat in combo_list:
   ...    sofi.analmat( mat )
   ... 
   ('E', 0, 1, array([1., 0., 0.]), 0.0)
   ('S', 0, 1, array([1., 0., 0.]), 0.0)
   ('S', 0, 1, array([0., 1., 0.]), 0.0)
   ('S', 0, 1, array([0., 0., 1.]), 0.0)
   ('C', 2, 1, array([0., 0., 1.]), 0.5)
   ('C', 2, 1, array([0., 1., 0.]), 0.5)
   ('C', 2, 1, array([1., 0., 0.]), 0.5)
   ('I', 2, 1, array([1., 0., 0.]), 0.5)
   >>> ##
   >>> ## get point group and principal axis of the new list
   >>> pg, prin_ax = sofi.get_pg( n_combo, combo_list )
   >>> pg
   'D2h'
   >>> prin_ax
   array([0., 0., 1.])
   >>> ##
   >>> ## a more verbose output can be obtained by setting `verb=True`:
   >>> sofi.get_pg( n_combo, combo_list, verb = True )

.. warning::
   SOFI only outputs one principal axis, however there are point groups which exhibit several equivalent axes,
   for which the choice of principal axis is ambiguous.


Test generator elements
=======================

Now we can test by trial-and-error if certain symmetry elements are generator elements of a group.
For example, the Td point group should be possible to generate from two S4 operations on perpendicular axes.

   >>> ## create empty list of two 3x3 matrices
   >>> mat_list = np.zeros( [2, 3, 3] )
   >>> ##
   >>> ## create two S4 operations, on perpendicular axes
   >>> mat_list[0] = sofi.construct_operation("S", np.array([1., 0., 0.]), 1/4)
   >>> mat_list[1] = sofi.construct_operation("S", np.array([0., 1., 0.]), 1/4)
   >>> ##
   >>> ## generate all combinations
   >>> nc, mc = sofi.mat_combos(2, mat_list)
   >>> ##
   >>> ## determine point group
   >>> sofi.get_pg( nc, mc )
   ('Td', array([-0.57735027, -0.57735027,  0.57735027]))



Matrix distance, or the resolving power of SOFI
===============================================

In SOFI, two matrices are considered equal when the function ``matrix_distance()`` returns a
value below the threshold ``m_thr``, the default value for which is ``m_thr=0.73``. Example:

   >>> ## create two matrices: S4 and C2 on the same axis
   >>> m1 = sofi.construct_operation( "S", np.array([ 1., 0., 0.]), 1/4 )
   >>> m2 = sofi.construct_operation( "C", np.array([ 1., 0., 0.]), 1/2 )
   >>> ##
   >>> ## compute distance between them
   >>> sofi.matrix_distance( m1, m2 )
   2.8284271247461903
   >>> ##
   >>> ## create matrices which are similar:
   >>> m1 = sofi.construct_operation( "C", np.array([1., 0., 0.]), 0.5 )
   >>> m2 = sofi.construct_operation( "C", np.array([1., 0., 0.]), 0.51 )
   >>> sofi.matrix_distance( m1, m2 )
   0.08884304298544585

The value of ``matrix_distance`` can be seen as the order of the matrix needed to transform ``m1`` into ``m2``.
The threshold ``m_thr`` is set to a value such that the rotation C12^1 can be resolved:

   >>> ## identity
   >>> m1 = sofi.construct_operation( "E", np.array([1., 0., 0.]), 0. )
   >>> ## C12^1
   >>> m2 = sofi.construct_operation( "C", np.array([1., 0., 0.]), 1/12 )
   >>> sofi.matrix_distance( m1, m2 )
   0.7320508075688772



.. note::
   The value of ``m_thr`` effectively determines the `resolving power` of SOFI. For groups containing
   operations with order higher than C12, the value should be adjusted, and the ``src`` recompiled.
   In that case, take care of array sizes, as they might exceed ``nmax``, and to adjust the procedure
   in ``analmat()``.




Symmetry operations of an atomic structure
==========================================

Using the ``get_symm_ops()`` function of SOFI to obtain the list of symmetry operations
of a given atomic structure works like:

   >>> import numpy as np
   >>> import ira_mod
   >>> sofi=ira_mod.SOFI()
   >>> ##
   >>> ## create a hypothetical atomic structure with 6 atoms:
   >>> nat = 6
   >>> ## all atomic types equal, integer value 1
   >>> typ = np.ones( [nat], dtype=int)
   >>> ## atomic positions
   >>> coords = np.array([[-0.65 ,  1.126,  0.   ],
   ...                    [-0.65 , -1.126,  0.   ],
   ...                    [ 1.3  , -0.   ,  0.   ],
   ...                    [-1.04 ,  0.   ,  0.   ],
   ...                    [ 0.52 , -0.901,  0.   ],
   ...                    [ 0.52 ,  0.901,  0.   ]])
   >>> ##
   >>> ## specify the symmetry threshold value
   >>> sym_thr = 0.05
   >>> ##
   >>> ## get the symmetry operations in form of 3x3 matrices
   >>> n_mat, mat_list = sofi.get_symm_ops( nat, typ, coords, sym_thr )

The list of matrices can now be input into ``get_pg()``:

   >>> sofi.get_pg( n_mat, mat_list )
   ('D3h', array([0., 0., 1.]))

Thus, the structure has D3h point group, with principal axis in the (0, 0, 1) direction.
You can view the hypothetical structure in your favourite visualiser software, and confirm the
symmetry operations and their axes, listed by SOFI:

   >>> for mat in mat_list:
   ...   sofi.analmat( mat )

.. note::
   The structure we have set up as ``coords`` has a geometric mean at (0, 0, 0), it can be confirmed:

      >>> np.mean( coords, axis=0 )
      array([0., 0., 0.])

   In subsequent how-tos we will work with structures where this is not necessarily the case.



Applying symmetry operations
============================

Upon transforming a structure with its symmetry operation, we obtain back the same structure.
Take the same hypothetical structure from before, it has a C3 operation on axis (0, 0, 1):

   >>> ## create a hypothetical atomic structure with 6 atoms:
   >>> nat = 6
   >>> ## all atomic types equal, integer value 1
   >>> typ = np.ones( [nat], dtype=int)
   >>> ## atomic positions
   >>> coords = np.array([[-0.65 ,  1.126,  0.   ],
   ...                    [-0.65 , -1.126,  0.   ],
   ...                    [ 1.3  , -0.   ,  0.   ],
   ...                    [-1.04 ,  0.   ,  0.   ],
   ...                    [ 0.52 , -0.901,  0.   ],
   ...                    [ 0.52 ,  0.901,  0.   ]])
   >>> ##
   >>> ## create C3 along (0, 0, 1)
   >>> c3mat = sofi.construct_operation( "C", np.array([0., 0., 1.]), 1/3)
   >>> ##
   >>> ## create the transformed coords
   >>> coords_tf = np.zeros([nat, 3], dtype=float)
   >>> ##
   >>> ## apply C3 to original coords through np.matmul()
   >>> for i, v in enumerate( coords ):
   ...    coords_tf[i] = np.matmul( c3mat, v )
   ...
   >>> ##
   >>> ## print the transformed structure:
   >>> coords_tf
   array([[-6.504e-01, -1.126e+00,  0.000e+00],
          [ 1.300e+00,  3.576e-05,  0.000e+00],
          [-6.499e-01,  1.126e+00,  0.000e+00],
          [ 5.200e-01, -9.009e-01,  0.000e+00],
          [ 5.205e-01,  9.009e-01,  0.000e+00],
          [-1.040e+00,  7.153e-06,  0.000e+00]], dtype=float)
   >>> ##
   >>> ## notice the vectors are equal (within precision) to the original coords, except permuted.

To obtain the permutation of atoms which happens upon the transformation by a symmetry operation,
SOFI has the ``try_mat()`` function, which returns the value of distance between the original structure,
and the structure transformed by a given matrix, and the corresponding permutation of indices:

   >>> dmax, perm = sofi.try_mat( nat, typ, coords, c3mat )
   >>> ##
   >>> ## print the permutation
   >>> perm
   array([2, 0, 1, 5, 3, 4])
   >>> ## print the distance
   >>> dmax
   0.00033364459005079844


The low value of ``dmax`` confirms that ``c3mat`` is indeed a symmetry operation of the structure defined above.
If you now take ``coords_tf`` from above, permute them by ``perm``, and compute the maximal distance between atoms
``coords[i]`` and ``coords_tf_perm[i]``, you should obtain the value ``dmax``.

   >>> ## permute coords_tf by perm
   >>> coords_tf_perm = coords_tf[ perm ]
   >>> ##
   >>> ## create array for atom-atom distances
   >>> d=np.zeros([nat], dtype=float)
   >>> ##
   >>> ## compute atom-atom distances between the original coords and coords_tf_perm
   >>> for i, v in enumerate( coords ):
   ...    d[i] = np.linalg.norm( v - coords_tf_perm[i] )
   ...
   >>> np.max( d )
   0.000333580064184048


.. note::
   The ``sym_thr`` argument when computing ``get_symm_ops()`` is a threshold in terms of the distance ``dist`` as
   computed in this section. If an operation returns a distance value beyond ``sym_thr``, then SOFI will not
   consider that operation as a symmetry operation.



Disordered structures: missing operations
=========================================

Perform combinations.



Put it all together
===================

   >>> sym = sofi.compute( nat, typ, coords, sym_thr )
   >>> ##
   >>> ## see what is in `sym` (use tab)
   >>> sym.
   sym.angle    sym.dmax     sym.n        sym.op       sym.perm     sym.prin_ax
   sym.axis     sym.matrix   sym.n_sym    sym.p        sym.pg       sym.print()



Choosing the origin point
=========================


wishlist
--------

Ideas for how-to/examples:

   - test if particular matrix is a symmetry operation of a structure
   - find symmOps of atomic structure, geo center or specific atom as origin
   - disordered structure, non-complete group, find missing elements
